## MEMO -開発環境・APIについてのQ&A-
### By ご飯システム班の一人
***
2018 11/16
最初から細かくプログラムとμTRONの仕様を読んでおくことにした。
以下に気になった仕様と何故書いてあるのかわからないものを理解するためのメモを記す。

11/17

11/18
適当に追記・セクション分け改善

11/19
μTRONではなくμITRONであることに気づく
### 注意
このファイルは**マークダウン言語**で書かれています。txtファイルとしても読めると
思いますが、マークダウンならちょっと読みやすいです。
ブラウザ上で使えるマークダウンビューアとかを使うといいと思います。
github上なら自動で綺麗に表示されるはずです。
***

## μTRON 静的API等Q&A編

### そもそも開発環境ってどうなってるの？
nxtOSEKという、μITRON実装としてTOPPERS/JSPをRTOSとして用い、
GCCツールチェインによるコンパイルができる環境でプログラミングする。
と言っても意味がわからんが、要するにタスクの生成にμITRONのAPIが使えて、
nxtの制御にecrobot〜とかいうAPIが使えて、GCCでコンパイルできるってだけ。

ECrobotってのはnxtOSEKの定義しているnxt制御用APIの集合っぽい。

### #define \_MACRO\_ONLYって何？
.cfgファイルの先頭に書かれている#define \_MACRO\_ONLYの役割は
それ以降のファイルが`#include`された際に~~マクロ以外のC言語的な宣言~~
NULLのマクロ＊があるとエラーをおこしてしまうため、
その危険性がある部分を読み込まないようにすることのようだ。
(μITRON-4.02仕様書p37)。実際のヘッダファイルを見てみると、文字通りマクロのみを読み込む処理になっている。

ちなみに、TOPPERS内の<t_services.h>というヘッダファイルは、\_MACRO\_ONLY
を上の用途で使用している。よって、\_MACRO\_ONLYは名前を変えないほうが良いだろう。

＊NULLのマクロってなに？正直良くわからないが、実際のファイルを見る限りCの宣言部等は
ヘッダガードしておくのが良さそうだ。

### コンパイルするときには\_MACRO\_ONLYは定義されてる？
実際のコンパイル(make)時に.cfgファイルはMakefile内に指定されてあるように
変数にパスが渡されているが、ターゲットではない。
そもそも.cfgファイルはcファイルでもhファイルでもないのだからコンパイルされない。
実際のコンパイル時には\_MACRO\_ONLYは`#define`されていないことに
なっているはずである。
#### ＞ちなみに
Makefileは設定を行った後Ecrobotとかいうディレクトリ内にあるecrobot.mak
というファイルを読み込んでいる。~~おそらく実際のコンパイルはそちらで行われている
のだろう。「はず」だの「だろう」だのが多いのは実際の処理がわからないからである。~~
ecrobot.makを確認した。しかしMakefileを読むのは苦手でよくわからなかった。
おそらくコンフィギュレーションファイルの処理だとかを行っているだろう程度。

### INCLUDEってなに？`#include`とは何が違うの？
.cfgファイルの`INCLUDE`は静的APIの1つで、ほとんどC言語の`#include`と同じである。
しかし、コンフィギュレータ＊は`INCLUDE`しか理解できず、`#include`は
Cプリプロセッサが使用するものである。コンフィギュレータは`INCLUDE`を見つけると
その引数をそのままコピーし、**そのコンフィギュレータが生成するcファイルなりhファイルなり
の`#include`として使用する**ようだ。

例えばサンプルの.cfgでは`INCLUDE("\"jouga_cfg.h\"")`と
`INCLUDE("\"at91sam7s.h\"")`の２つが書かれているが、これが
コンフィギュレータを通ってkernel_cfg.cになった時には同じものが
`#include`で読み込まれている。

面白いことに、.cfgファイルは一度Cプリプロセッサに通されるらしい
(μITRON-4.02仕様書p34)。Cプリプロセッサとは本来C言語を整形するための
プログラムで、`#define`とか`#include`はプリプロセッサが処理するという話は
どこかで聞いたことがあるのではないか。

CプリプロセッサはC言語以外にも
利用可能(文法とかが似ていることが前提らしいが)で、μITRONでは整形した.cfgファイル
を生成するために使うよう指定しているようだ。

＊**コンフィギュレータ**：最終的にkernel_cfg.cなどのファイルを
出力するやつだと思う

##### ＞要するに
+ `#include`はCプリプロセッサが理解するもの
+ `INCLUDE`はそれ以外がコピペするもの

### 個人的な疑問1
.cfgファイルにおいてCRE_TSKという静的APIを用いることで、タスクを生成することが
できる。これは誰が見てもすぐわかるが、ここで1つ疑問が生じた。
.cfgファイルはCのファイルを読んでいないのだ。にもかかわらず、タスク指定時
Cの関数名を指定している。これは果たしてどのように行われているのか。

これはそのまま、コンフィギュレータが生成するkernel_cfg.cにおいて名前が
コピーされて、関数ポインタから呼び出されているだけのようだ。
その際、.cfgファイル内で`INCLUDE`されるファイル内に使用する関数が宣言されていない
と多分コンパイルエラーを起こす。
##### ＞要するに
そこを考える必要なし！でも`INCLUDE`忘れないこと！

### 個人的な疑問2
タスクにタスクIDとして静的APIに渡されている値がTinitとかよくわからん
値だが、これはどこで定義されているのか。

~~「定義されるのではなくここで定義している」が答えだろう。
IDが数値であるという思い込みからきた勘違いだ。~~

定義そのものはkernel_id.hで行われている。そのkernel_id.hはコンフィギュレータで
生成されるらしいから、上記の説明は間違っちゃいないかな？

### 割り込みハンドラって何？どんなときに使うんだ？
その名の通り、割り込みのハンドラらしい。外部からOSの処理にたいして割り込み
を行うことがあるが、その際に何をするかを決めるもののようだ。

教科書には、割り込みハンドラを定義する静的API `DEF_INH`を使用する場合、
事前に`at91sam7s.h`というファイルを`#include`かつ`INCLUDE`しなければ
ならない、といったことが書かれてあった。これに関しては
割り込み処理は基本的にはCPU依存だから、細かな実装は処理系ごとに
異なると仕様書にわざわざ書いてあった。おそらくこのファイルに`DEF_INH`とかに
使用する定義か何かが書いてあるのだろう。
だから変なものをINCLUDEしないといけないわけだ。

ライントレース用プログラムではjsp_systick_low_priorityが設定されている。


### 周期ハンドラってなに？
教科書にも仕様書にも、
>一定周期で起動されるタイムイベントハンドラである

と一言一句違わず書いてあるが、果たしてそれが何を意味しているのかわからない。
タイムイベントハンドラというのは、時間に関係するハンドラの総称であるといった
ようなことが一応仕様書には書いてある(p240)。
果たしてそれが何を意味しているのか。

前回のライントレース用プログラムにおける実装をみるに、ただ単純に周期的
に起動したい関数を指定するだけで良いようだ。

### 今更だけどハンドラとタスクは何が違うんだ？
+ タスクはOSが管理する並列処理の単位。
+ ハンドラはそれ以外の、OS外からの処理。

### タスクの優先順位が高いものが優先？
高い優先順位のタスクが待ち状態にならない限り、低い優先順位のものは起動できない。
タスクを公平にといった生ぬるい考えは存在しない。よって下手に無限ループのプログラムを
書くと電源を引き抜くしかなくなってしまう。

### 個人的なメモ：優先度逆転について
高い優先度のタスクが存在し、あるセマフォを待っているとする。他の低い優先度のタスクが
セマフォを持っていたとすると、**低い優先度のタスクが高い優先度のタスクの実行を妨げる**
状態に陥る。これを優先度逆転という。

これは基本OSが防いでくれるものではなく、アプリケーションを作るこちら側が判断しなければ
いけないことである。優先度の異なるタスク間でセマフォを共有しないことで避けることができる。
以上、OSの授業で習った。

***
## Cプログラミング＋サービスコールQ&A編

### サービスコールって何？
仕様書曰く、
>アプリケーションプログラムからカーネル
>またはソフトウェア部品を呼び出すインターフェース

のことらしい。要するにAPIのことだね。`act_tsk`とかがそうです。

### タスク用の関数にある引数ってなに？
タスク用として存在している関数にはみんな`VP_INT exinf`という引数がある。
タスク用関数に与えられる引数は仕様書では拡張情報と呼ばれている。
基本は静的APIにおいて定義された拡張情報が渡されるようだが、
サービスコールである`sta_tsk`から呼び出す際には
この引数に直接値を渡すことができるようだ。

あとは`VP_INT`だが、これは仕様書に以下の定義があった。
>データタイプが定まらないものへのポインタまたはプロセッサに自然な
>サイズの符号付き整数

要するに普通の`int`だろう。`int`も実際ポインタとして使用することが可能だし。
ちなみに前回のプログラムではタスク起動に`act_tsk`を使用していた。
これは引数に値を渡すこと無くタスクを起動するサービスコールのことである。

### 何を`#include`しなきゃいけないの？
##### .cfg内(INCLUDE含む)
+ _cfg.h タスク用関数の宣言箇所
+ at91sam7s.h 割り込みハンドラ使用用

##### _cfg.h内
+ t_services.h TOPPERSのAPIに対するヘッダ　内部に静的API用のマクロもある
+ .h ヘッダ　ただのヘッダで、静的API には関与しないはず

##### .c内
+ display.h ディスプレイ用関数　元々ECrobotにあるやつを書き直したものらしい
+ kernel_id.h タスクIDを定義している
+ button.h ボタンの状態が定義されてる
+ graphics.h グラッフィク用関数　使わないかも？
+ ecrobot_interface.h　ECrobot APIの関数が定義されてる
+ ecrobot_base.h　細かなよくわからない関数が定義されてる
+ 他に関数宣言したり定数宣言したりするファイル(_cfg.hや.h)

基本は/nxtOSEK内部にあるが、先生が書き直した一部はMakefileと同じところにある。

### iから始まるサービスコールって何？ついてないのと何が違うの？
iから名前が始まるサービスコール(iact_tsk等)は、タスク以外の部分からしか呼び出せない
サービスコールである。仕様書では**非タスクコンテキスト専用のサービスコール**
と呼ばれている。主にハンドラ内から呼び出すのが主になると思う。他のiから始まらない
サービスコールは、一部の例外を除きタスク以外では呼び出してはいけない。

### タスクを周期的(1msごと等)に起動したいです
元のサンプルプログラムでは2つの方法でそれを実現している。
１つはタスクをループさせ、そのうちで2進セマフォの獲得が必要であるとし、
周期ハンドラ内でセマフォを返却することで、周期的にタスクの進行を許可することにする方法。
もう１つはタスクを周期ハンドラから起動する方法。

両方周期ハンドラを使っているが、前者はタスクがループしている分タスク内の状態を
保護しやすい。まぁ後者でも多分静的変数を使えば状態保護できる？かもしれない。
サンプルでは前者は移動用タスク、後者はディスプレイ用タスクに使われていた。

#### 追記
もう1つあるのを忘れていた。`dly_tsk`を使って強制的にタスクを待ち状態にするというのも手である。
悪い点が余り思いつかないし、これを使ったほうが楽かもしれない。
#### 更に追記
サンプルプログラムのIdleTsk付近に書かれているコメントを読むと少し差異がわかった。
周期ハンドラからタスクを起動すると、前回起動されたタスクが終了していようが
いまいが、タスクを起動しようとする。その分の起動できなかったタスクはキューに入れられ、
タスク終了時にもう一度起動される(仕様書p81?よくわからない)。

これは待ちが起こるタスク内では無駄が多い。内部で待ちを行うタスクは周期ハンドラから
呼ばないほうがよいだろう。


### 見つけにくいAPIたち
+ **get_OS_flag**:
`ecrobot_base.c`に定義されている、`OS_flag`の値を取得する関数。
OS_flagはOSが開始されていたら1、それ以外で0を返す。

+ **ecrobot_poll_nxtstate**:
`ecrobot_interface.c`に定義されている、nxtの状態を更新する関数。多分。
ボタンの状態とバッテリー残量を更新するようだ。

+ **check_NXT_buttons**:
`ecrobot_base.c`に定義されている、`ecrobot_poll_nxtstate`のラッパー。多分。
1msに一回起動されることが前提らしいが、10msに一回ecrobot_poll_nxtstateを
呼び出す。後は自分たちで書いたオリジナルのプログラムが起動していない間、
キャンセルボタンを押したら電源が切れるようにしているのもこいつ。

+ **ecrobot_get_button_state**:
`ecrobot_interface.c`に定義されている、どのボタンが押されているかを返す関数。
`ecrobot_poll_nxtstate`を呼んで更新してから使わないと意味がない。
戻り値は押されているボタンを表す数値。buttons.hに定義されているnxtButtonsと一致する。
多分。

こいつらはどう検索してもほとんど出てこなかった。googleが英語版だからかな？
一部の関数はそれでも完全にはわかっていないが、ここまで分かれば一応はプログラムできるだろう。
特に上に書いた関数はボタンの制御に使わざるを得なかったりするので、
知っておくに越したことはないだろう。

### イベントフラグって何ビット？
スタンダードプロファイル(今回使ってる仕様だったはず)では16ビット**以上**らしい。
実装定義で、FLGPTNという型と同じ。

### TOPPERS/JSP特有の縛りとかある？
実装依存っていう言葉をすっかり忘れていた。一応簡単に調べてまとめておく。
+ イベントフラグのFLGPTNはunsigned int。大体16ビット。
+ イベントフラグ定義時、TA_WMULは指定できない、というかサポートされない。

### 参考文献
##### μITRON ver4.2.0仕様書
これが一番使えた
##### 教科書
実験の教科書のAPI部分は仕様書のコピペ
でもマルチタスク云々はわかりやすいと思う　たぶんね
##### https://www.tron.org/ja/onwebseminar/chap3/
多分tron公式のサイト なんか書いてある
##### https://osdn.net/projects/toppersjsp4bf/docs/user.pdf/ja/3/user.pdf.pdf
TOPPERS/JSPのマニュアル
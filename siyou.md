## MEMO -システム仕様書-
### By ご飯システム班の一人
システムの仕様を記しておきます。どのようなつもりでプログラムを書いたかは、
手続き型の言語だと眺めただけではわかりにくいし、コメントを書いても理解しにくい
というのが個人的な意見です。私が一人で作ってしまった部分は特に後からわからなく
なったら困るので、一応仕様書として残しておきます。

仮に明らかに仕様が間違っている・または仕様に対して
明らかに間違った実装がなされている場合には教えてください
### 注意
このファイルはマークダウン言語で書かれています。txtファイルとしても読めると
思いますが、マークダウンならちょっと読みやすいです。
ブラウザ上で使えるマークダウンビューアとかを使うといいと思います。
github上なら自動で綺麗に表示されるはずです。


## tl;dr　長文読みたくない人向け三行
+ strategyの中をいじろう
+ タスクはどうにか動くように作ってます
+ MoveLengthつかえば動くよ

# 基本機能
+ ヘッダー・フッターの常時描画
  + デバッグ情報・残り時間の表示
+ メニュー画面
  + メニュー画面でキャンセルを押すと電源が切れます。
  + メニュー画面から起動した関数の実行中キャンセルを押すとメニューにもどります。
  + サブメニュー
  + 変数の値変更
+ Move系API
  + パワー・回転比・移動距離を指定するだけでPID制御しつつ移動します。
+ ログ機能
  + 画面にログを残します

## 戦略用関数 Strategy
メニュー画面には戦略プログラムを起動する項目があります。
選択されると、現在設定されている戦略プログラムに基づいて
実際の制御を開始します。

起動される戦略プログラムを選択する項目も存在します。
実際に戦略を記入するのは、その項目で設定できる関数内になります。

## 移動関数 Move~
このシステムは基本的に**power**と**turn**の2つを指定することで機能します。

powerは単純にモータに与えるパワー、turnは
+ 絶対値は 「外側のタイヤに対し内側のタイヤは(100-turn%)回る」
+ 符号は「正なら左が外側、負なら右が外側」
を意味する値のことです。

一旦これらの値を設定した後、MoveTskというタスクを起動すると、モータに与えるパワーが
自動で制御されます。

この場合のPID制御の対象は「タイヤの回転角度の比」です。
私達は狙ったところにロボットが着きさえすればよく、
そのために必要なのは左右の回転角度の比だけであり、
正確な回転速度にはこだわる必要はないので、角度の比のみの制御を行います。

MoveTskは取得した外側のモータの回転角度に対する、内側のモータの回転角度の
比をとります。この比をtunrの絶対値と比べ、PID制御します。

### 12/14追記　
MoveTskがかなりバグっていることに気づきました。
これまで動いていたことが奇跡なレベルでした。
競技会以降修正した部分は以下の4点です

+ 変数の初期化位置の修正＝たまにエラーが逆にかかっていた
+ 逆走の禁止＝逆走することによるエラーの蓄積
+ 測定値の符号間違い＝超信地旋回設定時の暴走
+ 更新時間をパワーに反比例させる＝パワーによっては測定が足りない(常に0になったり)

## アーム系関数
アームを下げる関数と上げる関数の2つが存在します。
目標角度を、アーム用モータの回転方向に応じて上回るか下回るかしたときに
アームが目標点についたと考えます。

アームが何かに引っかかると目標角度に着きませんが、それでそれ以降の処理が
出来ないというのでは困るので、しばらくの間処理が終了しない場合タイムアウトと見なし
強制終了します。

アーム処理はタスク化していないのでこの関数を呼ぶとそこで処理がストップします。
すなわち、アームを上げてからイベントフラグを待つ、といったことは
出来ません。仮にそれが必要になるようならタスク化を考えます。

## ディスプレイ・ログ系関数
DispTskというタスクが常にヘッダーとフッターを描画し続けます。
ディスプレイは共有資源で、下手に並列で変更するとエラーを起こしかねないと
判断し、セマフォで占有権を制御することにしました。

この場合、ログを表示するだけでも
セマフォ待ち＞出力＞セマフォ返却　という処理が多く行われるので、
この一連の処理を行うラッパー関数を作りました。

注意点として、それらの関数を優先度の高いタスクから呼ぶ際、
優先度逆転が起こる可能性があるということを知っておいてください。
現状なにも手を打つつもりはありませんが、問題になるようなら対処します。

## メニュー関係
メニューには2種類存在します。1つはメインメニューのように項目を選択したらその
項目に対応した関数を起動する通常メニュー。もう1つは変数名が表示されその値を
設定できる変数変更用メニューです。

メニュー項目の設定は、メニュー項目を表す構造体の配列を
作成することで行います。
通常メニューの項目には対応する関数の起動モードを表すフィールドが存在します。
起動モードには
1. 対応する関数をタスクとして起動するモード
2. 直接ループ内で起動し、関数終了後はメニューが終了するモード
3. 直接ループ内で起動し、関数終了後もメニューが終了しないモード

の3種類があります。
通常メニュー内からさらに通常メニューを起動する際には2のモードに、
変数変更用メニューを起動する場合には3のモードにします。

**注意**:実際のモードに対応する整数値と、上記便宜的につけたモード番号は一致しません。

変数変更用メニュー項目には、変更する変数のデフォルト値を返す関数と
変数を実際に変更する関数を指定する必要があります。これらの関数はオブジェクト指向
で言うゲッターとセッターにあたります。

### 参考文献(ほとんど眺めただけ)：
##### 宇津木諭　絵ときでわかる機械制御 2006 オーム社
ほとんどラプラス空間で話をするし細かい実装とかは書いてないしであんまり
使えないなぁと思った
##### 志水清孝　フィードバック制御理論-安定化と最適化- 2013 コロナ社
じゃあ難しそうな本ならどうかと思ったら何書いてあるかさっぱりで
一時間ほど寝ました
